define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.queryAll = _exports.query = _exports.property = _exports.customElement = void 0;

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */

  /**
   * Class decorator factory that defines the decorated class as a custom element.
   *
   * @param tagName the name of the custom element to define
   *
   * In TypeScript, the `tagName` passed to `customElement` must be a key of the
   * `HTMLElementTagNameMap` interface. To add your element to the interface,
   * declare the interface in this module:
   *
   *     @customElement('my-element')
   *     export class MyElement extends LitElement {}
   *
   *     declare global {
   *       interface HTMLElementTagNameMap {
   *         'my-element': MyElement;
   *       }
   *     }
   *
   */
  var customElement = function customElement(tagName) {
    return function (clazz) {
      window.customElements.define(tagName, clazz); // Cast as any because TS doesn't recognize the return type as being a
      // subtype of the decorated class when clazz is typed as
      // `Constructor<HTMLElement>` for some reason. `Constructor<HTMLElement>`
      // is helpful to make sure the decorator is applied to elements however.

      return clazz;
    };
  };
  /**
   * A property decorator which creates a LitElement property which reflects a
   * corresponding attribute value. A `PropertyDeclaration` may optionally be
   * supplied to configure property features.
   */


  _exports.customElement = customElement;

  var property = function property(options) {
    return function (proto, name) {
      proto.constructor.createProperty(name, options);
    };
  };
  /**
   * A property decorator that converts a class property into a getter that
   * executes a querySelector on the element's renderRoot.
   */


  _exports.property = property;

  var query = _query(function (target, selector) {
    return target.querySelector(selector);
  });
  /**
   * A property decorator that converts a class property into a getter
   * that executes a querySelectorAll on the element's renderRoot.
   */


  _exports.query = query;

  var queryAll = _query(function (target, selector) {
    return target.querySelectorAll(selector);
  });
  /**
   * Base-implementation of `@query` and `@queryAll` decorators.
   *
   * @param queryFn exectute a `selector` (ie, querySelector or querySelectorAll)
   * against `target`.
   */


  _exports.queryAll = queryAll;

  function _query(queryFn) {
    return function (selector) {
      return function (proto, propName) {
        Object.defineProperty(proto, propName, {
          get: function get() {
            return queryFn(this.renderRoot, selector);
          },
          enumerable: true,
          configurable: true
        });
      };
    };
  } //# sourceMappingURL=decorators.js.map

});